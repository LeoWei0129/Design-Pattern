單例設計模式(Singleton)

基本介紹
所謂類的單例設計模式，就是採取一定的方法保證在整個軟件系統中，對某個類只能存在一個對例實例，並且該類只提供一個取得取得實例對象的方法(
靜態方法)
比如Hibernate的SessionFactory，它充當數據存儲源的代理，並負責創建Session對象。SessionFactory並不是輕量級的，一般情況下，一個項目
通常只需要一個SessionFactory，這時就會使用到單例設計模式

單例模式有8種方式
1. 餓漢式(靜態常量)
2. 餓漢式(靜態代碼塊)
3. 懶漢式(線程不安全)
4. 懶漢式(線程安全，同步方法)
5. 懶漢式(線程安全，同步代碼塊)
6. 雙重檢查
7. 靜態內部類
8. 枚舉

1. 餓漢式(靜態常量)
步驟如下
a. constructor私有化(不讓在外部透過new來創建對象)
b. 在類的內部創建對象
c. 向外暴露一個靜態的公共方法(getInstance)
分析說明
a. 優點: 這種寫法比較簡單，就是在類裝載的時候就完成實例化，避免了線程同步問題
b. 缺點: 在類裝載的時候就完成實例化，沒有達到Lazy Loading的效果，如果從始至終從未使用這個實例，則會造成內存的浪費
c. 分析: 這種方式基於classloader機制(類裝載)避免了多線程同步的問題，不過，導致類裝載的原因有很多種，因此不能確定有沒有其他的方式(
        或者其他的靜態方法)導致類裝載，這時候初始化instance就沒有達到Lazy Loading的效果
d. 結論: 這種單例模式可用，但可能造成內存浪費
-------------------------------------------------
2. 餓漢式(靜態代碼塊)
分析說明
a. 分析: 這種方式其實和上面的類似，只不過將類實例化的過程放在靜態代碼塊中，也是在類裝載的時候，就執行靜態代碼塊中的代碼，初始化類的
        實例，優缺點和上面是一樣的
b. 結論: 這種單例模式可用，但可能造成內存浪費
-------------------------------------------------
3. 懶漢式(線程不安全)
分析說明
a. 優點: 起到了Lazy Loading的效果，但是只能在單線程下使用
b. 缺點: 如果在多線程下，如果一個線程進入了if(instance==null)判斷語句塊，還未來得及往下執行，另一個線程也通過了這個判斷語句，這時便
         會產生多個instance實例，所以在多線程環境下不可使用這個方法
c. 結論: 在實際開發中，不能使用這個方法
-------------------------------------------------
4. 懶漢式(線程安全，同步方法)
分析說明
a. 優點: 解決了線程不安全的問題
b. 缺點: 效率太低了，每個線程在想獲得類的實例的時候，執行getInstance()方法都要進行同步，而其實這個方法只執行一次實例化代碼就夠了，後
         面的想獲得實例直接return就好了，方法進行同步效率太低
c. 結論: 在實際開發中，不推薦這個方法
-------------------------------------------------
5. 懶漢式(線程不安全，同步代碼塊)
分析說明
a. 優點: 這種方式，本意是想對第四種方式的改進，因為前面同步方法的效率太低，改為同步產生實例化的代碼塊
b. 缺點: 但是這種方式不能起到線程同步的作用，跟第三種方式遇到的情況一致，如果一個線程進入了if(instance==null)判斷語句塊，還未來得及
         往下執行，另一個線程也通過了這個判斷語句，這時便會產生多個instance實例
c. 結論: 在實際開發中，不能使用這個方法
-------------------------------------------------
6. 雙重檢查
分析說明
a. 優點: Double-Check概念是多線程開發中常用到的，如代碼中所示，我們進行了兩此if(instance==null)檢查，這樣就可以確保線程安全，此外，
         實例化代碼只要執行一次，後面的其他線程再次訪問時，會判斷if(instance==null)==false，直接return實例化對象，也避免反覆進行
         方法同步:
b. 結論: 線程安全，延遲加載，效率較高，在實際開發中，推薦使用
-------------------------------------------------
7. 靜態內部類
a. 優點: 這種方式採用了類裝載機制，JVM能保證初始化實例時只有一個線程
         靜態內部類方式在Singleton1類被裝載時不會立即被實例化，而是在需要實例化時，調用getInstance方法，才會裝載SingletonInstance
         類，從而完成Singleton1的實例化(延遲加載)
         類的靜態屬性只會在類的第一次加載類的時候初始化，所以在這裡，JVM幫助我們保證了線程安全，在類進行初始化時，別的線程是無法進入
         的(JVM線程安全+只會創建一個實例對象)
         此方法避免了線程不安全，利用靜態內部類實現延遲加載，效率高
b. 結論: 推薦使用
-------------------------------------------------

注意事項和細節說明
1. 單例模式保證了系統內存中該類只存在一個對象，節省了系統資源，對於一些需要頻繁創建銷毀的對象，使用單例模式可以提高系統性能
2. 當想實例化一個單例對象時，必須要記住使用相應的獲取對象的方法來獲取，而不是使用new
3. 單例模式使用的場景: 需要頻繁創建或銷毀的對象、創建對象時耗費時間或資源過多(即重量級對象)，但又經常用到的對象、工具類對象、頻繁訪問
   數據庫或文件的對象(比如數據源、session工廠等)