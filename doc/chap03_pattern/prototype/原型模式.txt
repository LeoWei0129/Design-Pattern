原型模式(Prototype)

先看一個需求: 複製羊問題
現在有一隻羊，姓名為Tom，年齡為1歲，顏色為白色，請編寫程序創建和Tom屬性完全相同的10隻羊

傳統方式解決此問題
1. 創建一個Sheep類，在客戶端創建10個這個類的對象
2. 此方法的優點是好理解，且容易操作
3. 在創建新的對象時，總是需要重新獲取原始對象的屬性，如果創建的對象比較複雜時，效率較低(ex: 假設有20個屬性，每次new時傳給constructor
   以及調用getXXX()時，都會變得麻煩)
4. 總是需要重新初始化對象，而不是動態地獲取對象運行時的狀態，不夠靈活
5. 改進思路: Java中Object類是所有類的基類，Object類提供了一個clone()方法，該方法可以將一個Java對象複製一份，但是需要實現clone()的
   Java類必須要實現一個接口Cloneable，該接口表示該類能夠複製且具有複製的能力
   => 原型模式
6. 使用原型模式，讓程式具有更高的效率和擴展性
7. 第3、4點可以理解為如果此時對象的屬性有更動，只要修改其所屬的類以及客戶端中的第一個new時傳入constructor中的參數即可，clone()會自
   動複製新的一份對象，若採用傳統方法，在每個new對象實例中，都需去修改變動的屬性，從而降低程式的維護性和擴展性

基本介紹
1. 用原型實例指定創建對象的種類，並且通過拷貝這些原型，創建新的對象
2. 原型模式是一種創建型模式，允許一個對象再創建另一個可制定的對象，無須知道創建的細節
3. 工作原理是: 通過將一個原型對象傳給那個要發動創建的對象(此對象其實就是原型對象它自己)，這個要發動創建的對象通過請求原型對象拷貝它們
   自己來實施創建
   => 即: 對象.clone()

原型模式原理結構圖說明(prototype.png)
1. Prototype: 原型類，聲明一個克隆自己的接口(聲明一個要有克隆功能的接口，也就是Cloneable接口)
2. ConcretePrototype: 具體的原型類，實現一個克隆自己的操作(此問題中，具體的原型類就是Sheep類)
3. Client: 讓一個原型對象克隆自己，從而創建一個新的對象(屬性一樣)

深入探討 - 深拷貝和淺拷貝
1. 淺拷貝
   a. 對於數據類型是基本類型的成員變量，淺拷貝會直接進行值傳遞，也就是將該屬性值複製一份給新對象
   b. 對於數據類型是引用類型的成員變量，比如說成員變量是某個數組、某個類的對象等，那麼淺拷貝會進行引用傳遞，也就是將該成員變量的引用值
      (內存地址)複製一份給新的對象，因為實際上兩個對象的該成員都指向同一個實例，在這種情況下，在一個對象中修改該成員變量會影響到另一個
      對象的該成員變量值
   c. 前面的複製羊問題是淺拷貝
   d. 淺拷貝是使用默認的clone()來實現
      => sheep = (Sheep)super.clone();
2. 深拷貝
   a. 複製對象的所有基本數據類型的成員變量值
   b. 為所有引用數據類型的成員變量申請存儲空間，並複製每個引用數據類型成員變量所引用的對象，直到該對象可達的所有對象，也就是說，對象進
      行深拷貝要對整個對象進行拷貝
   c. 實現方式1: 重寫clone()來實現深拷貝
   d. 實現方式2: 通過對象序列化實現深拷貝

注意事項和細節
1. 創建新的對象比較複雜時，可以利用原型模式簡化對象的創建過程，同時也能夠提高效率
2. 不用重新初始化對象，而是動態地獲取對象運行時的狀態
3. 如果原始對象發生變化(增加or減少屬性)，其他克隆對象也會發生相應的變化，無須修改代碼
4. 缺點: 需要為每一個類配備一個克隆方法，這對全新的類來說不是很難，但對已有的類進行改造時，需要修改其源代碼，違反了OCP原則

