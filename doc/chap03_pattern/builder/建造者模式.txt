建造者模式(Builder)

先看一個需求: 蓋房問題(builder_tradition.png)
1. 需要蓋房子； 這一過程有打樁、砌牆、封頂
2. 房子有各種各樣的，如公寓、透天、別墅，各種房子的建造過程雖然一樣，但是要求不要相同的
3. 先寫一個傳統方法(com.unimicron.pattern.builder.tradition.*)

傳統方法問題分析
1. 優點是比較好理解，簡單易操作
2. 設計的程序結構過於簡單，沒有設計緩存層對象，程序的擴展和維護不好，也就是說，這種設計方式，把產品(即: 房子)和創建產品的過程(即: 建
   房子的流程)封裝在一起，耦合性增強了
3. 解決方案: 將產品和產品創建過程解偶 => 建造者模式

基本介紹
1. 建造者模式又叫做生成者模式，是一種對象構建模式，它可以將複雜對象的建造過程抽象出來(抽象類別)，使這個抽象過程的不同實現方法可以構建
   出不同表現(屬性)的對象
2. 建造者模式是一步一步創建一個複雜的對象，它允許用戶只通過指定複雜對象的類型和內容就可以構建他們，用戶不需要知道內部的具體構建細節

建造者模式的四個角色(builder_architecture.png、builder_uml.png)
1. Product(產品角色): 一個具體的產品對象
2. Builder(抽象建造者): 創建一個Product對象的各部件指定的接口/抽象類，Builder負責產品建造的流程，定義了組成產品的各個部件
3. ConcreteBuilder(具體建造者): 實現接口，構件和封裝各個部件，實現建造的具體流程(ex: 公寓Builder、別墅Builder)
4. Director(指揮者): 構建一個使用Builder接口的對象，它主要是用於創建一個複雜的對象，它主要有兩個作用，一是: 隔離了客戶與對象的生產過
   程，二是: 控制產品對象的生產過程

建造者模式在JDK的應用與源碼分析(StringBuilder)
1. Appendable接口定義了多個append方法(抽象方法)，即Appendable為抽象建造者，定義了抽象方法
2. AbstractStringBuilder實現了Appendable的接口方法，這裡的AbstractStringBuilder已經是建造者，但是不能實例化
3. StringBuilder既充當了指揮者，也充當了具體建造者，建造方法的實現已由AbstractStringBuilder完成，StringBuilder只是繼承了
   AbstractStringBuilder

注意事項和細節
1. 客戶端(使用程序)不須知道產品內部的組成細節，將產品本身與產品的創建過程解藕，使得相同的創建過程可以創建不同的產品對象
2. 每一個具體建造者都相對獨立，而與其它的具體建造者無關，因此可以很方便地替換或新增具體建造者，用戶使用不同的具體建造者即可得到不同的
   產品對象
3. 可以更加精細地控制產品的創建過程，將複雜產品的創建步驟分解在不同的方法中，使得創建過程更加清晰，也更方便使用程序來控制創建過程
4. 新增新的具體構造者無須修改原有類庫的代碼，指揮者類針對抽象建造者類進行編程，系統擴展方便，符合開閉原則
5. 建造者模式所創建的產品一般具有較多的共同點，其組成部分相似，如果產品之間的差異性很大，則不適用建造者模式，因此其使用範圍受到一定限制
6. 如果產品的內部變化複雜，可能會導致需要定義很多具體建造者類來實現這些變化，導致系統變得很龐大，這種情況下，要慎重考慮是否要使用建造者
   模式
7. 抽象工廠模式 v.s. 建造者模式
   抽象工廠模式實現對產品家族的創建，一個產品家族是這樣的一系列產品，具有不同分類維度的產品組合，採用抽象工廠模式不需關心構造過程，只
   關心甚麼產品由甚麼工廠生產即可，而建造者模式則是要求按照指定的藍圖建造產品，它的主要目的是通過組裝零配件而產生一個新產品